"""
Documentation Tools for iam-doc Agent

This module provides tools for:
- Generating After-Action Reports (AARs)
- Updating README files
- Creating design documentation
- Managing 000-docs/ documentation structure
"""

import os
import logging
from typing import List, Dict, Any, Optional
from datetime import datetime
from pathlib import Path

logger = logging.getLogger(__name__)


def generate_aar(
    phase_name: str,
    objectives: List[str],
    outcomes: List[str],
    lessons_learned: List[str],
    next_steps: List[str],
    related_issues: Optional[List[str]] = None,
) -> Dict[str, Any]:
    """
    Generate an After-Action Report (AAR) for a completed phase.

    An AAR documents what happened in a phase, what was learned, and what comes next.
    It follows the 000-docs/ filing system naming convention.

    Args:
        phase_name: Name of the phase (e.g., "Phase 1 - Design & Scaffold")
        objectives: List of original objectives for this phase
        outcomes: List of actual outcomes and deliverables
        lessons_learned: Key insights and learnings from the phase
        next_steps: Recommended actions for future phases
        related_issues: Optional list of GitHub issue IDs related to this phase

    Returns:
        Dictionary containing AAR structure with:
        - file_name: Proposed filename following 000-docs convention
        - content: Markdown content of the AAR
        - metadata: Phase metadata (date, related issues, etc.)

    Example:
        >>> aar = generate_aar(
        ...     phase_name="Phase 1 - iam-doc Agent Creation",
        ...     objectives=["Create iam-doc agent", "Implement documentation tools"],
        ...     outcomes=["Agent created successfully", "Tools implemented"],
        ...     lessons_learned=["ADK patterns work well for specialized agents"],
        ...     next_steps=["Deploy to Agent Engine", "Integrate with foreman"]
        ... )
        >>> print(aar['file_name'])
        NNN-AA-REPT-iam-doc-creation.md
    """
    logger.info(f"Generating AAR for phase: {phase_name}")

    # Generate timestamp
    timestamp = datetime.now().isoformat()

    # Create AAR content following standard template
    content = f"""# After-Action Report: {phase_name}

**Date:** {datetime.now().strftime('%Y-%m-%d')}
**Phase:** {phase_name}

## Executive Summary

This AAR documents the execution of {phase_name}, including objectives, outcomes, lessons learned, and recommendations for future phases.

## Objectives

"""
    for i, obj in enumerate(objectives, 1):
        content += f"{i}. {obj}\n"

    content += "\n## Outcomes\n\n"
    for i, outcome in enumerate(outcomes, 1):
        content += f"{i}. {outcome}\n"

    content += "\n## Lessons Learned\n\n"
    for i, lesson in enumerate(lessons_learned, 1):
        content += f"{i}. {lesson}\n"

    content += "\n## Next Steps\n\n"
    for i, step in enumerate(next_steps, 1):
        content += f"{i}. {step}\n"

    if related_issues:
        content += "\n## Related Issues\n\n"
        for issue in related_issues:
            content += f"- {issue}\n"

    content += f"""
## Metadata

- **Generated:** {timestamp}
- **Generator:** iam-doc agent
- **Filing System:** Document Filing System v2.0
- **Category:** AA (After-Action Report)

---

*This AAR was auto-generated by iam-doc Documentation Specialist agent.*
"""

    # Generate file name (NNN placeholder - caller should replace with actual sequence number)
    file_name = f"NNN-AA-REPT-{phase_name.lower().replace(' ', '-').replace('phase-', '').strip('-')}.md"

    result = {
        "file_name": file_name,
        "content": content,
        "metadata": {
            "phase_name": phase_name,
            "timestamp": timestamp,
            "objectives_count": len(objectives),
            "outcomes_count": len(outcomes),
            "related_issues": related_issues or [],
        },
    }

    logger.info(f"AAR generated successfully: {file_name}")
    return result


def update_readme(
    readme_path: str,
    section_name: str,
    new_content: str,
    append: bool = False,
) -> Dict[str, Any]:
    """
    Update a section in a README file.

    Args:
        readme_path: Path to the README.md file (absolute or relative to repo root)
        section_name: Name of the section to update (e.g., "## Quick Start")
        new_content: New content for the section
        append: If True, append to existing section instead of replacing

    Returns:
        Dictionary containing:
        - success: Boolean indicating if update succeeded
        - updated_path: Path to the updated README
        - changes_made: Description of changes

    Example:
        >>> result = update_readme(
        ...     readme_path="/home/jeremy/000-projects/iams/bobs-brain/README.md",
        ...     section_name="## Agents",
        ...     new_content="### iam-doc\\n\\nDocumentation specialist agent."
        ... )
        >>> print(result['success'])
        True
    """
    logger.info(f"Updating README section '{section_name}' in {readme_path}")

    try:
        # Validate path exists
        path = Path(readme_path)
        if not path.exists():
            logger.error(f"README not found at {readme_path}")
            return {
                "success": False,
                "updated_path": readme_path,
                "changes_made": f"Error: README not found at {readme_path}",
            }

        # Read existing content
        with open(path, "r") as f:
            content = f.read()

        # Find section
        lines = content.split("\n")
        section_start = -1
        section_end = -1

        for i, line in enumerate(lines):
            if line.strip().startswith(section_name):
                section_start = i
            elif section_start >= 0 and line.strip().startswith("## "):
                section_end = i
                break

        if section_start == -1:
            logger.warning(f"Section '{section_name}' not found in {readme_path}")
            return {
                "success": False,
                "updated_path": readme_path,
                "changes_made": f"Section '{section_name}' not found",
            }

        # If no end found, section goes to end of file
        if section_end == -1:
            section_end = len(lines)

        # Build updated content
        if append:
            # Append to existing section
            updated_lines = (
                lines[: section_end]
                + [new_content]
                + (lines[section_end:] if section_end < len(lines) else [])
            )
            changes_made = f"Appended content to section '{section_name}'"
        else:
            # Replace section content
            updated_lines = (
                lines[: section_start + 1]
                + [new_content]
                + (lines[section_end:] if section_end < len(lines) else [])
            )
            changes_made = f"Replaced content in section '{section_name}'"

        # Write back
        with open(path, "w") as f:
            f.write("\n".join(updated_lines))

        logger.info(f"README updated successfully: {changes_made}")
        return {
            "success": True,
            "updated_path": str(path),
            "changes_made": changes_made,
        }

    except Exception as e:
        logger.error(f"Failed to update README: {e}", exc_info=True)
        return {
            "success": False,
            "updated_path": readme_path,
            "changes_made": f"Error: {str(e)}",
        }


def create_design_doc(
    title: str,
    purpose: str,
    architecture: str,
    decisions: List[Dict[str, str]],
    alternatives: Optional[List[Dict[str, str]]] = None,
) -> Dict[str, Any]:
    """
    Create a design document for architectural decisions.

    Args:
        title: Title of the design document
        purpose: Purpose and context for this design
        architecture: Description of the proposed architecture
        decisions: List of decisions with 'decision' and 'rationale' keys
        alternatives: Optional list of alternatives considered

    Returns:
        Dictionary containing:
        - file_name: Proposed filename
        - content: Markdown content
        - metadata: Document metadata

    Example:
        >>> doc = create_design_doc(
        ...     title="iam-doc Agent Architecture",
        ...     purpose="Document the design of the documentation specialist agent",
        ...     architecture="LlmAgent with documentation tools",
        ...     decisions=[
        ...         {
        ...             "decision": "Use FunctionTool for AAR generation",
        ...             "rationale": "Simple, testable, follows ADK patterns"
        ...         }
        ...     ]
        ... )
    """
    logger.info(f"Creating design document: {title}")

    timestamp = datetime.now().isoformat()

    content = f"""# Design Document: {title}

**Date:** {datetime.now().strftime('%Y-%m-%d')}
**Status:** Draft

## Purpose

{purpose}

## Architecture

{architecture}

## Key Decisions

"""
    for i, decision in enumerate(decisions, 1):
        content += f"### Decision {i}: {decision['decision']}\n\n"
        content += f"**Rationale:** {decision['rationale']}\n\n"

    if alternatives:
        content += "## Alternatives Considered\n\n"
        for i, alt in enumerate(alternatives, 1):
            content += f"### Alternative {i}: {alt['alternative']}\n\n"
            content += f"**Reason Not Chosen:** {alt['reason']}\n\n"

    content += f"""
## Metadata

- **Generated:** {timestamp}
- **Generator:** iam-doc agent
- **Filing System:** Document Filing System v2.0
- **Category:** AT (Architecture & Technical)

---

*This design document was auto-generated by iam-doc Documentation Specialist agent.*
"""

    file_name = f"NNN-AT-ARCH-{title.lower().replace(' ', '-')}.md"

    result = {
        "file_name": file_name,
        "content": content,
        "metadata": {
            "title": title,
            "timestamp": timestamp,
            "decisions_count": len(decisions),
            "alternatives_count": len(alternatives) if alternatives else 0,
        },
    }

    logger.info(f"Design document created: {file_name}")
    return result


def list_documentation(
    docs_dir: str = "/home/jeremy/000-projects/iams/bobs-brain/000-docs",
    category_filter: Optional[str] = None,
) -> Dict[str, Any]:
    """
    List all documentation files in 000-docs/ directory.

    Args:
        docs_dir: Path to 000-docs directory
        category_filter: Optional category code to filter by (e.g., "AA", "AT", "PP")

    Returns:
        Dictionary containing:
        - total_docs: Total number of documents
        - docs: List of document info (filename, category, type, title)
        - categories: Summary by category

    Example:
        >>> result = list_documentation(category_filter="AA")
        >>> print(f"Found {result['total_docs']} AAR documents")
    """
    logger.info(f"Listing documentation in {docs_dir}")

    try:
        path = Path(docs_dir)
        if not path.exists():
            logger.warning(f"Docs directory not found: {docs_dir}")
            return {
                "total_docs": 0,
                "docs": [],
                "categories": {},
            }

        docs = []
        categories = {}

        for file in path.glob("*.md"):
            # Parse filename: NNN-CC-ABCD-description.md
            parts = file.stem.split("-", 3)
            if len(parts) >= 3:
                seq_num = parts[0]
                category = parts[1]
                doc_type = parts[2] if len(parts) > 2 else "UNKN"
                description = parts[3] if len(parts) > 3 else "untitled"

                # Apply category filter
                if category_filter and category != category_filter:
                    continue

                doc_info = {
                    "filename": file.name,
                    "sequence": seq_num,
                    "category": category,
                    "type": doc_type,
                    "title": description.replace("-", " ").title(),
                    "path": str(file),
                }

                docs.append(doc_info)

                # Track categories
                if category not in categories:
                    categories[category] = 0
                categories[category] += 1

        logger.info(f"Found {len(docs)} documents")
        return {
            "total_docs": len(docs),
            "docs": sorted(docs, key=lambda x: x["sequence"]),
            "categories": categories,
        }

    except Exception as e:
        logger.error(f"Failed to list documentation: {e}", exc_info=True)
        return {
            "total_docs": 0,
            "docs": [],
            "categories": {},
            "error": str(e),
        }
